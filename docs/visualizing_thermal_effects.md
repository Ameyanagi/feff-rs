# Visualizing Thermal Effects in XAS

This guide shows how to visualize the thermal effects data generated by the feff-rs library, with a focus on the outputs from the `thermal_effects_example.rs` example.

## Recommended Tools

Several tools are suitable for visualizing XAS thermal effects:

- **Python with Matplotlib**: Flexible plotting with scripting capabilities
- **Gnuplot**: Simple command-line plotting tool
- **Origin/OriginPro**: Commercial software with advanced plotting features
- **R with ggplot2**: Statistical analysis and visualization

## Python/Matplotlib Examples

### 1. Mean-Square Displacements vs. Temperature

```python
import numpy as np
import matplotlib.pyplot as plt

# Load data from thermal_models_msd.dat
data = np.loadtxt('thermal_models_msd.dat', skiprows=1)
temp = data[:, 0]
debye_msd = data[:, 1]
einstein_msd = data[:, 2]
correlated_msd = data[:, 3]

# Create plot
plt.figure(figsize=(10, 6))
plt.plot(temp, debye_msd, 'o-', label='Debye Model')
plt.plot(temp, einstein_msd, 's-', label='Einstein Model')
plt.plot(temp, correlated_msd, '^-', label='Correlated Debye Model')

# Add classical linear trend line for comparison
classical = debye_msd[5] * temp / temp[5]  # Normalize to 300K point
plt.plot(temp, classical, '--', label='Classical (linear) trend', alpha=0.6)

plt.xlabel('Temperature (K)')
plt.ylabel('Mean-Square Displacement (Å²)')
plt.title('Temperature Dependence of Thermal Vibrations')
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.savefig('msd_vs_temperature.png', dpi=300)
plt.show()
```

### 2. Debye-Waller Factors vs. Wavenumber

```python
import numpy as np
import matplotlib.pyplot as plt

# Load data from debye_waller_factors.dat
data = np.loadtxt('debye_waller_factors.dat', skiprows=1)
k_values = data[:, 0]
debye_dw = data[:, 1]
einstein_dw = data[:, 2]
correlated_dw = data[:, 3]

# Create plot
plt.figure(figsize=(10, 6))
plt.plot(k_values, debye_dw, '-', label='Debye Model')
plt.plot(k_values, einstein_dw, '-', label='Einstein Model')
plt.plot(k_values, correlated_dw, '-', label='Correlated Debye Model')

# Add reference exponential curves
k_ref = np.linspace(2, 15, 100)
for sigma_sq in [0.003, 0.006, 0.009]:
    dw_ref = np.exp(-2 * k_ref**2 * sigma_sq)
    plt.plot(k_ref, dw_ref, ':', alpha=0.6, 
             label=f'Reference σ² = {sigma_sq:.3f} Å²')

plt.xlabel('Wavenumber k (Å⁻¹)')
plt.ylabel('Debye-Waller Factor exp(-2k²σ²)')
plt.title('Debye-Waller Factors for Different Thermal Models at 300K')
plt.legend()
plt.grid(True, alpha=0.3)
plt.ylim(0, 1.0)
plt.tight_layout()
plt.savefig('debye_waller_factors.png', dpi=300)
plt.show()
```

### 3. Anisotropic Effects

```python
import numpy as np
import matplotlib.pyplot as plt

# Load data from anisotropic_thermal.dat
data = np.loadtxt('anisotropic_thermal.dat', skiprows=1, 
                  dtype=[('direction', 'U15'), ('cubic', float), 
                         ('tetragonal', float), ('layered', float)])

# Extract data
directions = [d[0] for d in data]
cubic_dw = np.array([d[1] for d in data])
tetragonal_dw = np.array([d[2] for d in data])
layered_dw = np.array([d[3] for d in data])

# Create bar chart
x = np.arange(len(directions))
width = 0.25

fig, ax = plt.subplots(figsize=(12, 7))
rects1 = ax.bar(x - width, cubic_dw, width, label='Cubic')
rects2 = ax.bar(x, tetragonal_dw, width, label='Tetragonal')
rects3 = ax.bar(x + width, layered_dw, width, label='Layered')

# Add labels and legend
ax.set_ylabel('Debye-Waller Factor at k = 8 Å⁻¹')
ax.set_title('Anisotropic Thermal Effects by Crystal System')
ax.set_xticks(x)
ax.set_xticklabels(directions, rotation=45, ha='right')
ax.legend()

# Add value labels above bars
def autolabel(rects):
    for rect in rects:
        height = rect.get_height()
        ax.annotate(f'{height:.3f}',
                    xy=(rect.get_x() + rect.get_width() / 2, height),
                    xytext=(0, 3),
                    textcoords="offset points",
                    ha='center', va='bottom', fontsize=8)

autolabel(rects1)
autolabel(rects2)
autolabel(rects3)

plt.tight_layout()
plt.savefig('anisotropic_thermal_effects.png', dpi=300)
plt.show()
```

### 4. Effect on EXAFS Spectrum

```python
import numpy as np
import matplotlib.pyplot as plt

# Simulate the effect of different Debye-Waller factors on an EXAFS spectrum
# This is a demonstration - in practice, you would use actual EXAFS data

# Create a simple simulated EXAFS spectrum
k = np.linspace(3, 15, 400)
chi_0 = 0.5 * np.sin(5*k) * np.exp(-0.5*k) / k

# Apply different Debye-Waller factors
sigma_sq_values = [0.001, 0.003, 0.006, 0.009]
plt.figure(figsize=(10, 6))

# Plot original spectrum
plt.plot(k, chi_0, 'k-', label='No thermal effects')

# Plot with different thermal effects
for sigma_sq in sigma_sq_values:
    dw_factor = np.exp(-2 * k**2 * sigma_sq)
    chi_thermal = chi_0 * dw_factor
    plt.plot(k, chi_thermal, '--', 
             label=f'σ² = {sigma_sq:.3f} Å² (≈ {int(sigma_sq*1000/3)}K)')

plt.xlabel('Wavenumber k (Å⁻¹)')
plt.ylabel('EXAFS χ(k)')
plt.title('Effect of Thermal Disorder on EXAFS Spectrum')
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.savefig('thermal_effects_on_exafs.png', dpi=300)
plt.show()
```

## Gnuplot Examples

### 1. Basic Plot of MSD vs. Temperature

```gnuplot
set terminal pngcairo size 800,600 enhanced font 'Arial,12'
set output 'msd_temperature_gnuplot.png'
set xlabel 'Temperature (K)'
set ylabel 'Mean-Square Displacement (Å²)'
set title 'Temperature Dependence of Thermal Vibrations'
set key top left
set grid
plot 'thermal_models_msd.dat' using 1:2 with linespoints title 'Debye Model', \
     '' using 1:3 with linespoints title 'Einstein Model', \
     '' using 1:4 with linespoints title 'Correlated Debye Model'
```

### 2. Debye-Waller Factors

```gnuplot
set terminal pngcairo size 800,600 enhanced font 'Arial,12'
set output 'debye_waller_gnuplot.png'
set xlabel 'Wavenumber k (Å⁻¹)'
set ylabel 'Debye-Waller Factor exp(-2k²σ²)'
set title 'Debye-Waller Factors for Different Thermal Models'
set key bottom left
set grid
set yrange [0:1]
plot 'debye_waller_factors.dat' using 1:2 with lines title 'Debye Model', \
     '' using 1:3 with lines title 'Einstein Model', \
     '' using 1:4 with lines title 'Correlated Debye Model'
```

## Interpreting the Visualizations

### Mean-Square Displacements

In the MSD vs. temperature plot:

- **Low temperature region**: The curves should deviate from linear behavior due to quantum effects. The MSDs don't go to zero at 0K due to zero-point motion.
- **High temperature region**: The curves should approach linear behavior (classical limit).
- **Comparing models**: The Einstein model typically shows higher MSDs than the Debye model at the same temperature, while the correlated model shows lower effective MSDs.

### Debye-Waller Factors

In the DW factors plot:

- The curves should decrease exponentially with increasing k.
- At a given k value, a larger MSD (σ²) results in a smaller DW factor.
- The DW factor at k=0 should always be 1.0.
- The slope of the curve (in log scale) is proportional to the MSD.

### Anisotropic Effects

In the anisotropic effects visualization:

- **Cubic materials**: Should show the same DW factor in all directions.
- **Tetragonal materials**: Should show smaller DW factors (more damping) along the z-axis.
- **Layered materials**: Should show much smaller DW factors along the z-axis (perpendicular to layers).
- The relative differences increase with increasing k values.

## Advanced Visualizations

### Thermal Ellipsoids

To visualize anisotropic thermal parameters as thermal ellipsoids:

```python
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib.patches import FancyArrowPatch
from mpl_toolkits.mplot3d import proj3d

# Class for 3D arrows
class Arrow3D(FancyArrowPatch):
    def __init__(self, xs, ys, zs, *args, **kwargs):
        super().__init__((0,0), (0,0), *args, **kwargs)
        self._verts3d = xs, ys, zs

    def draw(self, renderer):
        xs3d, ys3d, zs3d = self._verts3d
        xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, renderer.M)
        self.set_positions((xs[0], ys[0]), (xs[1], ys[1]))
        super().draw(renderer)

# Define different thermal ellipsoids
def plot_thermal_ellipsoid(ax, center, U, scale=1.0, color='r', alpha=0.3, label=None):
    # Create grid of points on a sphere
    u = np.linspace(0, 2 * np.pi, 30)
    v = np.linspace(0, np.pi, 20)
    x = np.outer(np.cos(u), np.sin(v))
    y = np.outer(np.sin(u), np.sin(v))
    z = np.outer(np.ones_like(u), np.cos(v))
    
    # Stack the coordinates into a 3xn array
    points = np.vstack([x.flatten(), y.flatten(), z.flatten()])
    
    # Apply the transformation matrix U (thermal ellipsoid)
    U_matrix = np.diag(U)
    ellipsoid_points = scale * U_matrix @ points
    
    # Reshape back to grid format
    x_ellipsoid = ellipsoid_points[0].reshape(x.shape) + center[0]
    y_ellipsoid = ellipsoid_points[1].reshape(y.shape) + center[1]
    z_ellipsoid = ellipsoid_points[2].reshape(z.shape) + center[2]
    
    # Plot the ellipsoid
    ax.plot_surface(x_ellipsoid, y_ellipsoid, z_ellipsoid, 
                    color=color, alpha=alpha, label=label)

# Create figure
fig = plt.figure(figsize=(12, 10))
ax = fig.add_subplot(111, projection='3d')

# Plot thermal ellipsoids for different crystal systems
# Center, thermal displacement parameters (σx, σy, σz), scale
systems = [
    ("Cubic", [0, 0, 0], [1.0, 1.0, 1.0], 1.0, 'blue'),
    ("Tetragonal", [3, 0, 0], [1.0, 1.0, 1.5], 1.0, 'red'),
    ("Layered", [6, 0, 0], [1.0, 1.0, 2.5], 1.0, 'green')
]

for name, center, U, scale, color in systems:
    plot_thermal_ellipsoid(ax, center, U, scale, color, alpha=0.3)
    
    # Add text label
    ax.text(center[0], center[1], center[2] + 2, name, 
            ha='center', va='center', fontsize=12)
    
    # Add coordinate axes
    for axis, direction in zip(range(3), [[1,0,0], [0,1,0], [0,0,1]]):
        arrow = Arrow3D([center[0], center[0] + direction[0]], 
                        [center[1], center[1] + direction[1]], 
                        [center[2], center[2] + direction[2]], 
                        mutation_scale=15, lw=1, arrowstyle='-|>', color='black')
        ax.add_artist(arrow)

# Set plot limits and labels
ax.set_xlim(-1, 8)
ax.set_ylim(-2, 2)
ax.set_zlim(-2, 3)
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.set_title('Thermal Vibration Ellipsoids for Different Crystal Systems')

plt.tight_layout()
plt.savefig('thermal_ellipsoids.png', dpi=300)
plt.show()
```

### 3D Correlation Factor Visualization

To visualize how correlation factors vary with distance:

```python
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm
from mpl_toolkits.mplot3d import Axes3D

# Calculate correlation factor as a function of distance
def correlation_factor(r):
    # Example implementation based on the correlated Debye model
    typical_first_shell = 2.5
    characteristic_length = 3.0
    
    if r <= typical_first_shell:
        return 0.8
    else:
        corr = 0.8 * np.exp(-(r - typical_first_shell) / characteristic_length)
        return max(0.0, min(1.0, corr))

# Create a grid of x,y coordinates
x = np.linspace(-10, 10, 100)
y = np.linspace(-10, 10, 100)
X, Y = np.meshgrid(x, y)

# Calculate distance from origin and corresponding correlation factor
R = np.sqrt(X**2 + Y**2)
Z = np.array([correlation_factor(r) for r in R.flatten()]).reshape(R.shape)

# Create 3D surface plot
fig = plt.figure(figsize=(12, 9))
ax = fig.add_subplot(111, projection='3d')
surf = ax.plot_surface(X, Y, Z, cmap=cm.coolwarm, alpha=0.8, 
                      linewidth=0, antialiased=True)

# Add color bar
cbar = fig.colorbar(surf, ax=ax, shrink=0.5, aspect=10)
cbar.set_label('Correlation Factor')

# Add annotations for characteristic distances
theta = np.linspace(0, 2*np.pi, 100)
for r in [2.5, 5.5, 8.5]:
    x_circle = r * np.cos(theta)
    y_circle = r * np.sin(theta)
    z_circle = correlation_factor(r) * np.ones_like(theta)
    ax.plot(x_circle, y_circle, z_circle, 'k--', alpha=0.6)
    
    # Label the circle
    ax.text(r, 0, correlation_factor(r) + 0.05, 
            f'{r:.1f} Å, corr={correlation_factor(r):.2f}', 
            ha='center', va='bottom')

ax.set_xlabel('X (Å)')
ax.set_ylabel('Y (Å)')
ax.set_zlabel('Correlation Factor')
ax.set_title('Correlation Factor as a Function of Distance')
ax.set_zlim(0, 1)

plt.tight_layout()
plt.savefig('correlation_factor_3d.png', dpi=300)
plt.show()
```

## Conclusion

Effective visualization is crucial for understanding the thermal models in XAS:

1. **Temperature-dependent plots** help you verify the correct physics and temperature trends
2. **k-dependent plots** show how thermal effects impact EXAFS at different wavenumbers
3. **Directional comparisons** reveal anisotropic effects in non-cubic materials
4. **3D visualizations** help conceptualize thermal ellipsoids and correlation effects

These visualizations can be used to:
- Validate your thermal model implementations
- Select appropriate thermal parameters for your material
- Understand the impact of thermal effects on your XAS analysis
- Compare theoretical models with experimental data

Remember that thermal effects are more pronounced at:
- Higher temperatures
- Higher k values
- Along directions with enhanced thermal vibrations